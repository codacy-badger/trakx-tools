@page "/livenav"
@using System.Collections.Concurrent
@using System.Threading
@using Microsoft.AspNetCore.SignalR.Client;
@using Microsoft.Extensions.DependencyInjection
@using Trakx.Data.Market.Common.Pricing
@using Trakx.Data.Market.Server.Hubs
@using Trakx.Data.Models.Index
@inject NavigationManager NavigationManager
@inject NavHub NavHub
@inject IIndexDefinitionProvider IndexDefinitionProvider

<h1>Live Index NAV</h1>

<input id="symbol" @onchange="ChangeSymbol" />
<button class="btn btn-primary" id="addSymbol" @onclick="AddSymbol">Add</button>
<button class="btn btn-primary" id="removeSymbol" @onclick="RemoveSymbol">Remove</button>
<br />

<p>NavHub Uri: @_liveNavUri</p>
<br />

<p>@_message</p>
<br />

<table class="table small">
    @if (_updatesBySymbol.Any())
    {
        <tr>
            <td>Updated</td>
            <td>Symbol</td>
            <td>NAV</td>
        </tr>
    }
    @foreach (var update in _updatesBySymbol.Values)
    {
        <tr>
            <td>@update.TimeStamp.ToString("yyyyMMdd - hh:mm:ss")</td>
            <td>@update.Symbol</td>
            <td>@update.Value.ToString("F4")</td>
        </tr>
    }
</table>
<br />

@code {

    private string _symbol = string.Empty;
    private string _message = "Register for updates by adding and index symbol above";

    private ConcurrentDictionary<string, NavUpdate> _updatesBySymbol =
        new ConcurrentDictionary<string, NavUpdate>();
    private Uri _liveNavUri;
    private HubConnection _connection;

    private readonly Guid _clientId = Guid.NewGuid();

    public async Task AddSymbol()
    {
        var addMe = _symbol;

        var index = await IndexDefinitionProvider.GetDefinitionFromSymbol(addMe).ConfigureAwait(false);
        if (index == IndexDefinition.Default)
        {
            _message = $"Unable to retrieve definition for index {addMe}";
            return;
        }

        await _connection.InvokeCoreAsync<bool>(nameof(NavHub.RegisterClientToNavUpdates),
            new object[] { _clientId, addMe }).ConfigureAwait(false);

        _updatesBySymbol.TryAdd(_symbol, new NavUpdate(addMe, 0));
    }

    public async Task RemoveSymbol()
    {
        var deleteMe = _symbol;

        await _connection.InvokeCoreAsync<bool>(nameof(NavHub.DeregisterClientFromNavUpdates),
            new object[] { deleteMe }).ConfigureAwait(false);
        _updatesBySymbol.TryRemove(_symbol, out var _);
    }

    public void ChangeSymbol(ChangeEventArgs change)
    {
        _symbol = change.Value?.ToString() ?? string.Empty;
    }

    protected override async Task OnInitializedAsync()
    {
        _updatesBySymbol = new ConcurrentDictionary<string, NavUpdate>();

        if (!Uri.TryCreate(new Uri(NavigationManager.BaseUri), "/hubs/nav", out var liveNavUri)) return;
        _liveNavUri = liveNavUri;
        _connection = new HubConnectionBuilder()
            .WithUrl(_liveNavUri)
            .AddJsonProtocol()
            .Build();

        await _connection.StartAsync();

        var channel = await _connection.StreamAsChannelAsync<NavUpdate>("NavUpdatesStream", CancellationToken.None);
        while (await channel.WaitToReadAsync())
        {
            while (channel.TryRead(out var update))
            {
                var updateResult = _updatesBySymbol.AddOrUpdate(update.Symbol, _ => update,
                    (s, oldValue) => (oldValue.TimeStamp < update.TimeStamp) ? update : oldValue);

                if (updateResult == update) StateHasChanged();
            }
        }
    }
}
