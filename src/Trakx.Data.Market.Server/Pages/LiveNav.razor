@page "/livenav"
@using System.Collections.Concurrent
@using System.Runtime.CompilerServices
@using System.Threading
@using Microsoft.AspNetCore.SignalR.Client;
@using Microsoft.Extensions.DependencyInjection
@using Microsoft.Extensions.Logging
@using Trakx.Data.Market.Common.Pricing
@using Trakx.Data.Market.Server.Hubs
@using Trakx.Data.Models.Index
@inject NavigationManager NavigationManager
@inject IIndexDefinitionProvider IndexDefinitionProvider
@inject INavUpdater NavUpdater
@implements IDisposable

<h1>Live Index NAV</h1>

<input id="symbol" @onchange="ChangeSymbol" />
<button class="btn btn-primary" id="addSymbol" @onclick="AddSymbol">Add</button>
<button class="btn btn-primary" id="removeSymbol" @onclick="RemoveCurrentSymbol">Remove</button>
<br />

<p>@_message</p>
<br />

<table class="table small">
    @if (_updatesBySymbol.Any())
    {
        <tr>
            <td>Updated</td>
            <td>Symbol</td>
            <td>NAV</td>
        </tr>
    }
    @foreach (var update in _updatesBySymbol.Values)
    {
        <tr>
            <td>@update.TimeStamp.ToString("yyyyMMdd - hh:mm:ss")</td>
            <td>@update.Symbol</td>
            <td>@update.Value.ToString("F4")</td>
        </tr>
    }
</table>
<br />

@code {

    private string _symbol = string.Empty;
    private string _message = "Register for updates by adding and index symbol above";
    private bool _completed;
    private Exception _failed;

    private ConcurrentDictionary<string, NavUpdate> _updatesBySymbol =
        new ConcurrentDictionary<string, NavUpdate>();

    private IDisposable _navUpdateSubscription;
    private CancellationTokenSource _cancellationTokenSource = new CancellationTokenSource();

    private readonly Guid _clientId = Guid.NewGuid();

    public async Task AddSymbol()
    {
        var addMe = _symbol;

        try
        {
            var index = await IndexDefinitionProvider.GetDefinitionFromSymbol(addMe)
                .ConfigureAwait(false);
            if (index == IndexDefinition.Default)
            {
                _message = $"Unable to retrieve definition for index {addMe}";
                return;
            }

            await NavUpdater.RegisterToNavUpdates(_clientId, index);
        }
        catch (Exception e)
        {
            var message = $"Failed to add symbol {addMe}";
            //logger.LogWarning(e, message);
            _message = message;
        }

        _updatesBySymbol.TryAdd(_symbol, new NavUpdate(addMe, 0));
    }

    public void RemoveCurrentSymbol()
    {
        var deleteMe = _symbol;
        RemoveSymbol(deleteMe);
    }

    private void RemoveSymbol(string deleteMe)
    {
        try
        {
            NavUpdater.DeregisterFromNavUpdates(_clientId, deleteMe);
        }
        catch (Exception e)
        {
            var message = $"Failed to remove symbol {deleteMe}";
            //logger.LogWarning(e, message);
            _message = message;
        }

        _updatesBySymbol.TryRemove(_symbol, out var _);
    }

    public void ChangeSymbol(ChangeEventArgs change)
    {
        _symbol = change.Value?.ToString() ?? string.Empty;
    }

    public void RegisterException(Exception e)
    {
        _failed = e;
    }

    public void RegisterCompleted()
    {
        _completed = true;
    }

    public async Task ReceiveNavUpdate(NavUpdate update)
    {
        if (!_updatesBySymbol.ContainsKey(update.Symbol)) return;
        var updateResult = _updatesBySymbol.AddOrUpdate(update.Symbol, _ => update,
            (s, oldValue) => (oldValue.TimeStamp < update.TimeStamp) ? update : oldValue);

        if (updateResult == update) await InvokeAsync(StateHasChanged);
    }

    protected override async Task OnInitializedAsync()
    {
        _updatesBySymbol = new ConcurrentDictionary<string, NavUpdate>();
        _navUpdateSubscription = NavUpdater.NavUpdates
            .Subscribe(async u => await ReceiveNavUpdate(u),
                RegisterException,
                RegisterCompleted);
    }

    public void Dispose()
    {
            _cancellationTokenSource?.Cancel();
        foreach (var symbol in _updatesBySymbol)
        {
            _updatesBySymbol.Keys.ToList().ForEach(RemoveSymbol);
        }
        _navUpdateSubscription?.Dispose();
        _cancellationTokenSource?.Dispose();
    }

}
